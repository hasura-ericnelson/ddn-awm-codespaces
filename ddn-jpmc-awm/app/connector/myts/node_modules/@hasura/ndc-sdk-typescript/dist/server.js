"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startServer = void 0;
const fastify_1 = __importDefault(require("fastify"));
const api_1 = __importStar(require("@opentelemetry/api"));
const error_1 = require("./error");
const logging_1 = require("./logging");
const schema_1 = require("./schema");
const instrumentation_1 = require("./instrumentation");
const prom_client_1 = require("prom-client");
// Create custom Ajv options to handle Rust's uint32 which is a format used in the JSON schemas, so this converts that to a number
const customAjvOptions = {
    allErrors: true,
    removeAdditional: true,
    formats: {
        uint32: {
            validate: (data) => {
                return (typeof data === "number" &&
                    data >= 0 &&
                    data <= 4294967295 &&
                    Number.isInteger(data));
            },
            type: "number",
        },
    },
};
const errorResponses = {
    400: schema_1.ErrorResponseSchema,
    403: schema_1.ErrorResponseSchema,
    409: schema_1.ErrorResponseSchema,
    422: schema_1.ErrorResponseSchema,
    500: schema_1.ErrorResponseSchema,
    501: schema_1.ErrorResponseSchema,
    502: schema_1.ErrorResponseSchema,
};
const tracer = api_1.default.trace.getTracer("ndc-sdk-typescript.server");
async function startServer(connector, options) {
    const configuration = await connector.parseConfiguration(options.configuration);
    const metrics = new prom_client_1.Registry();
    (0, prom_client_1.collectDefaultMetrics)({ register: metrics });
    const state = await connector.tryInitState(configuration, metrics);
    const server = (0, fastify_1.default)({
        logger: (0, logging_1.configureFastifyLogging)(options),
        ajv: {
            customOptions: customAjvOptions,
        },
    });
    // temporary: use JSON.stringify instead of https://github.com/fastify/fast-json-stringify
    // todo: remove this once issue is addressed https://github.com/fastify/fastify/issues/5073
    server.setSerializerCompiler(({ schema, method, url, httpStatus, contentType }) => {
        return (data) => JSON.stringify(data);
    });
    server.addHook("preHandler", (request, reply, done) => {
        const expectedAuthHeader = options.serviceTokenSecret === undefined
            ? undefined
            : `Bearer ${options.serviceTokenSecret}`;
        if (request.headers.authorization === expectedAuthHeader) {
            return done();
        }
        else {
            reply.code(401).send({
                message: "Internal Error",
                details: {
                    cause: "Bearer token does not match.",
                },
            });
            return reply;
        }
    });
    server.get("/capabilities", {
        schema: {
            response: {
                200: schema_1.CapabilitiesResponseSchema,
                ...errorResponses,
            },
        },
    }, (_request) => {
        return (0, instrumentation_1.withActiveSpan)(tracer, "getCapabilities", () => connector.getCapabilities(configuration));
    });
    server.get("/health", (_request) => {
        return connector.healthCheck(configuration, state);
    });
    server.get("/metrics", (_request) => {
        connector.fetchMetrics(configuration, state);
        return metrics.metrics();
    });
    server.get("/schema", {
        schema: {
            response: {
                200: schema_1.SchemaResponseSchema,
                ...errorResponses,
            },
        },
    }, (_request) => {
        return (0, instrumentation_1.withActiveSpan)(tracer, "getSchema", () => connector.getSchema(configuration));
    });
    server.post("/query", {
        schema: {
            body: schema_1.QueryRequestSchema,
            response: {
                200: schema_1.QueryResponseSchema,
                ...errorResponses,
            },
        },
    }, async (request) => {
        request.log.debug({ requestHeaders: request.headers, requestBody: request.body }, "Query Request");
        const queryResponse = await (0, instrumentation_1.withActiveSpan)(tracer, "handleQuery", () => connector.query(configuration, state, request.body));
        request.log.debug({ responseBody: queryResponse }, "Query Response");
        return queryResponse;
    });
    server.post("/query/explain", {
        schema: {
            body: schema_1.QueryRequestSchema,
            response: {
                200: schema_1.ExplainResponseSchema,
                ...errorResponses,
            },
        },
    }, async (request) => {
        request.log.debug({ requestHeaders: request.headers, requestBody: request.body }, "Explain Request");
        const explainResponse = await (0, instrumentation_1.withActiveSpan)(tracer, "handleQueryExplain", () => connector.queryExplain(configuration, state, request.body));
        request.log.debug({ responseBody: explainResponse }, "Query Explain Response");
        return explainResponse;
    });
    server.post("/mutation", {
        schema: {
            body: schema_1.MutationRequestSchema,
            response: {
                200: schema_1.MutationResponseSchema,
                ...errorResponses,
            },
        },
    }, async (request) => {
        request.log.debug({ requestHeaders: request.headers, requestBody: request.body }, "Mutation Request");
        const mutationResponse = await (0, instrumentation_1.withActiveSpan)(tracer, "handleMutation", () => connector.mutation(configuration, state, request.body));
        request.log.debug({ responseBody: mutationResponse }, "Mutation Response");
        return mutationResponse;
    });
    server.post("/mutation/explain", {
        schema: {
            body: schema_1.MutationRequestSchema,
            response: {
                200: schema_1.ExplainResponseSchema,
                ...errorResponses,
            },
        },
    }, async (request) => {
        request.log.debug({ requestHeaders: request.headers, requestBody: request.body }, "Mutation Explain Request");
        const explainResponse = await (0, instrumentation_1.withActiveSpan)(tracer, "handleMutationExplain", () => connector.mutationExplain(configuration, state, request.body));
        request.log.debug({ responseBody: explainResponse }, "Mutation Explain Response");
        return explainResponse;
    });
    server.setErrorHandler(function (error, _request, reply) {
        // pino trace instrumentation will add trace information to log output
        this.log.error(error);
        if (error.validation) {
            reply.status(400).send({
                message: "Validation Error - https://fastify.dev/docs/latest/Reference/Validation-and-Serialization#error-handling",
                details: error.validation,
            });
        }
        else if (error instanceof error_1.ConnectorError) {
            // Send error response
            reply.status(error.statusCode).send({
                message: error.message,
                details: error.details ?? {},
            });
        }
        else {
            const span = api_1.default.trace.getActiveSpan();
            span?.recordException(error);
            span?.setStatus({ code: api_1.SpanStatusCode.ERROR });
            reply.status(500).send({
                message: error.message,
                details: {},
            });
        }
    });
    try {
        await server.listen({ port: options.port, host: "0.0.0.0" });
    }
    catch (error) {
        server.log.error(error);
        process.exitCode = 1;
    }
}
exports.startServer = startServer;
//# sourceMappingURL=server.js.map