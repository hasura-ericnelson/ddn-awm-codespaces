"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.getFlags = exports.mapObjectValues = exports.throwError = exports.isArray = exports.unreachable = void 0;
const unreachable = (x) => { throw new Error(`Unreachable code reached! The types lied! ðŸ˜­ Unexpected value: ${x}`); };
exports.unreachable = unreachable;
function isArray(x) {
    return Array.isArray(x);
}
exports.isArray = isArray;
// Throws an error. Useful for using after a short-circuiting ?? operator to eliminate null/undefined from the type
function throwError(...args) {
    throw new Error(...args);
}
exports.throwError = throwError;
function mapObjectValues(obj, fn) {
    return Object.fromEntries(Object.entries(obj).map(([prop, val]) => [prop, fn(val, prop)]));
}
exports.mapObjectValues = mapObjectValues;
/**
 * Returns all the set bitwise flags in a value, where the flags are defined on an enum type.
 * Useful for debugging TypeScript API types (eg ts.Type.flags with enum ts.TypeFlags)
 */
function getFlags(flagsEnum, value) {
    return Object
        .keys(flagsEnum)
        .flatMap(k => {
        const k_int = parseInt(k);
        return isNaN(k_int)
            ? []
            : (value & k_int) !== 0
                ? [flagsEnum[k]]
                : [];
    });
}
exports.getFlags = getFlags;
function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
}
exports.sleep = sleep;
//# sourceMappingURL=util.js.map