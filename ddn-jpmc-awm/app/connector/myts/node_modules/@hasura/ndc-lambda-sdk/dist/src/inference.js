"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printFunctionIssues = exports.printCompilerDiagnostics = exports.deriveSchema = void 0;
const typescript_1 = __importDefault(require("typescript"));
const tsutils = __importStar(require("ts-api-utils"));
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = __importDefault(require("node:fs"));
const schema = __importStar(require("./schema"));
const util_1 = require("./util");
const result_1 = require("./result");
function deriveSchema(functionsFilePath) {
    const programResult = createTsProgram(functionsFilePath);
    if (programResult instanceof result_1.Ok) {
        const { program, compilerDiagnostics, ndcLambdaSdkModule } = programResult.data;
        const sourceFile = program.getSourceFile(functionsFilePath);
        const projectRootDir = getProjectRootDirectory(functionsFilePath);
        if (!sourceFile)
            throw new Error(`'${functionsFilePath}' not returned as a TypeScript compiler source file`);
        const [functionsSchema, functionIssues] = deriveSchemaFromFunctions(sourceFile, projectRootDir, program.getTypeChecker(), ndcLambdaSdkModule);
        return {
            compilerDiagnostics,
            functionsSchema,
            functionIssues
        };
    }
    else {
        return {
            compilerDiagnostics: programResult.error,
            functionIssues: {},
            functionsSchema: {
                functions: {},
                objectTypes: {},
                scalarTypes: {}
            }
        };
    }
}
exports.deriveSchema = deriveSchema;
function createTsProgram(functionsFilePath) {
    return loadTsConfig(functionsFilePath).bind(parsedCommandLine => {
        const compilerHost = typescript_1.default.createCompilerHost(parsedCommandLine.options);
        const sdkModule = typescript_1.default.resolveModuleName("@hasura/ndc-lambda-sdk", functionsFilePath, parsedCommandLine.options, compilerHost);
        if (sdkModule.resolvedModule === undefined)
            throw new Error("Unable to resolve module '@hasura/ndc-lambda-sdk'");
        const program = typescript_1.default.createProgram([functionsFilePath], parsedCommandLine.options, compilerHost);
        const compilerDiagnostics = typescript_1.default.getPreEmitDiagnostics(program);
        return compilerDiagnostics.find(d => d.category === typescript_1.default.DiagnosticCategory.Error) === undefined
            ? new result_1.Ok({ program, compilerDiagnostics: [...compilerDiagnostics], ndcLambdaSdkModule: sdkModule.resolvedModule })
            : new result_1.Err([...compilerDiagnostics]);
    });
}
function loadTsConfig(functionsFilePath) {
    const functionsDir = node_path_1.default.dirname(functionsFilePath);
    const userTsConfig = typescript_1.default.findConfigFile(functionsDir, typescript_1.default.sys.fileExists);
    // If the user doesn't have a tsconfig, use this one as a fallback. The TypeScript defaults are bad
    // (eg. strict and strictNullChecks is off by default)
    const fallbackTsConfig = node_path_1.default.resolve(require.resolve("@tsconfig/node20/tsconfig.json"));
    const configPath = userTsConfig ?? fallbackTsConfig;
    const configFile = typescript_1.default.readConfigFile(configPath, typescript_1.default.sys.readFile);
    if (configFile.error) {
        return new result_1.Err([configFile.error]);
    }
    // If we're using the fallback tsconfig, override the include path to point to the user's
    // functions directory, otherwise it will look in the fallback tsconfig's directory
    if (userTsConfig === undefined) {
        configFile.config.include = [node_path_1.default.join(functionsDir, "./**/*")];
    }
    const parsedCommandLine = typescript_1.default.parseJsonConfigFileContent(configFile.config, typescript_1.default.sys, node_path_1.default.dirname(configPath));
    if (parsedCommandLine.errors.find(d => d.category === typescript_1.default.DiagnosticCategory.Error) !== undefined) {
        return new result_1.Err([...parsedCommandLine.errors]);
    }
    return new result_1.Ok(parsedCommandLine);
}
function getProjectRootDirectory(functionsFilePath) {
    let currentDir = node_path_1.default.dirname(functionsFilePath);
    while (true) {
        const packageJsonPath = node_path_1.default.join(currentDir, "package.json");
        if (node_fs_1.default.existsSync(packageJsonPath)) {
            return currentDir;
        }
        const parentDir = node_path_1.default.dirname(currentDir);
        // If we've reached the root and have found no package.json
        // just use the directory that the functions file is in
        if (parentDir === currentDir)
            return node_path_1.default.dirname(functionsFilePath);
        currentDir = parentDir;
    }
}
function printCompilerDiagnostics(diagnostics) {
    const host = {
        getNewLine: () => typescript_1.default.sys.newLine,
        getCurrentDirectory: typescript_1.default.sys.getCurrentDirectory,
        getCanonicalFileName: x => x
    };
    console.error(typescript_1.default.formatDiagnosticsWithColorAndContext(diagnostics, host));
}
exports.printCompilerDiagnostics = printCompilerDiagnostics;
function printFunctionIssues(functionIssues) {
    for (const [functionName, issues] of Object.entries(functionIssues)) {
        for (const issue of issues) {
            console.error(`${functionName}: ${issue}`);
        }
    }
}
exports.printFunctionIssues = printFunctionIssues;
function cloneTypeDerivationContext(context) {
    return {
        objectTypeDefinitions: structuredClone(context.objectTypeDefinitions),
        scalarTypeDefinitions: structuredClone(context.scalarTypeDefinitions),
        customTypeNameRegistry: context.customTypeNameRegistry.clone(),
        typeChecker: context.typeChecker,
        ndcLambdaSdkModule: context.ndcLambdaSdkModule,
    };
}
function deriveSchemaFromFunctions(sourceFile, projectRootDir, typeChecker, ndcLambdaSdkModule) {
    const typeDerivationContext = {
        objectTypeDefinitions: {},
        scalarTypeDefinitions: {},
        customTypeNameRegistry: new CustomTypeNameRegistry(),
        typeChecker,
        ndcLambdaSdkModule
    };
    const schemaFunctions = {};
    const functionIssues = {};
    const sourceFileSymbol = typeChecker.getSymbolAtLocation(sourceFile) ?? (0, util_1.throwError)("sourceFile does not have a symbol");
    const functionDeclarations = typeChecker.getExportsOfModule(sourceFileSymbol).flatMap(exportedSymbol => {
        const declaration = exportedSymbol.getDeclarations()?.[0] ?? (0, util_1.throwError)("exported symbol does not have a declaration");
        // If exported via 'export { name } from "./imported"'
        // or 'import { name } from "./imported"; export { name }'
        if (typescript_1.default.isExportSpecifier(declaration)) {
            const identifier = declaration.name ?? (0, util_1.throwError)("export declaration didn't have an identifier");
            const exportTarget = typeChecker.getExportSpecifierLocalTargetSymbol(declaration) ?? (0, util_1.throwError)("export specifier does not have a local target symbol");
            const exportTargetDeclaration = exportTarget.valueDeclaration // 'export { name } from "./imported"'
                ?? typeChecker.getAliasedSymbol(exportTarget).valueDeclaration // 'import { name } from "./imported"; export { name }'
                ?? (0, util_1.throwError)("export target symbol does not have a value declaration");
            if (typescript_1.default.isFunctionDeclaration(exportTargetDeclaration)) {
                return [[identifier.text, exportTargetDeclaration]];
            }
        }
        // If just a plain function export or exported via 'export * from "./imported"'
        else if (typescript_1.default.isFunctionDeclaration(declaration)) {
            const identifier = declaration.name ?? (0, util_1.throwError)("function declaration didn't have an identifier");
            return [[identifier.text, declaration]];
        }
        return [];
    });
    for (const [exportedFunctionName, functionDeclaration] of functionDeclarations) {
        const result = deriveFunctionSchema(functionDeclaration, exportedFunctionName, typeDerivationContext);
        if (result instanceof result_1.Ok) {
            schemaFunctions[exportedFunctionName] = result.data;
        }
        else {
            functionIssues[exportedFunctionName] = result.error;
        }
    }
    const functionsSchema = {
        functions: schemaFunctions,
        objectTypes: typeDerivationContext.objectTypeDefinitions,
        scalarTypes: typeDerivationContext.scalarTypeDefinitions,
    };
    const finalTypeNames = typeDerivationContext.customTypeNameRegistry.determineFinalTypeNames(projectRootDir, typeChecker);
    const finalFunctionSchema = applyFinalTypeNamesToFunctionsSchema(functionsSchema, finalTypeNames);
    return [finalFunctionSchema, functionIssues];
}
function deriveFunctionSchema(functionDeclaration, exportedFunctionName, context) {
    const functionIdentifier = functionDeclaration.name ?? (0, util_1.throwError)("Function didn't have an identifier");
    const functionSymbol = context.typeChecker.getSymbolAtLocation(functionIdentifier) ?? (0, util_1.throwError)(`Function '${exportedFunctionName}' didn't have a symbol`);
    const functionType = context.typeChecker.getTypeOfSymbolAtLocation(functionSymbol, functionDeclaration);
    const functionDescription = getDescriptionFromJsDoc(functionSymbol, context.typeChecker);
    const markedReadonlyInJsDoc = functionSymbol.getJsDocTags().find(e => e.name === "readonly") !== undefined;
    const allowRelaxedTypes = functionSymbol.getJsDocTags().find(e => e.name === "allowrelaxedtypes") !== undefined;
    const parallelDegreeResult = getParallelDegreeFromJsDoc(functionSymbol, markedReadonlyInJsDoc);
    const functionCallSig = functionType.getCallSignatures()[0] ?? (0, util_1.throwError)(`Function '${exportedFunctionName}' didn't have a call signature`);
    const functionSchemaArguments = result_1.Result.traverseAndCollectErrors(functionCallSig.getParameters(), paramSymbol => {
        const paramName = paramSymbol.getName();
        const paramDesc = typescript_1.default.displayPartsToString(paramSymbol.getDocumentationComment(context.typeChecker)).trim();
        const paramType = context.typeChecker.getTypeOfSymbolAtLocation(paramSymbol, paramSymbol.valueDeclaration ?? (0, util_1.throwError)(`Function '${exportedFunctionName}' parameter '${paramName}' didn't have a value declaration`));
        const paramTypePath = [{ segmentType: "FunctionParameter", functionName: exportedFunctionName, parameterName: paramName }];
        return deriveSchemaTypeForTsType(paramType, { type: "Symbol", symbol: paramSymbol }, paramTypePath, allowRelaxedTypes, context)
            .map(paramTypeResult => ({
            argumentName: paramName,
            description: paramDesc ? paramDesc : null,
            type: paramTypeResult,
        }));
    });
    const returnType = functionCallSig.getReturnType();
    const unwrappedReturnType = unwrapPromiseType(returnType, context.typeChecker) ?? returnType;
    const returnTypeResult = deriveSchemaTypeForTsType(unwrappedReturnType, { type: "FunctionReturn", callSignature: functionCallSig }, [{ segmentType: "FunctionReturn", functionName: exportedFunctionName }], allowRelaxedTypes, context);
    return result_1.Result.collectErrors3(functionSchemaArguments, returnTypeResult, parallelDegreeResult)
        .map(([functionSchemaArgs, returnType, parallelDegree]) => ({
        description: functionDescription,
        ndcKind: markedReadonlyInJsDoc ? schema.FunctionNdcKind.Function : schema.FunctionNdcKind.Procedure,
        arguments: functionSchemaArgs,
        resultType: returnType,
        parallelDegree,
    }));
}
function getDescriptionFromJsDoc(symbol, typeChecker) {
    const description = typescript_1.default.displayPartsToString(symbol.getDocumentationComment(typeChecker)).trim();
    return description ? description : null;
}
function getParallelDegreeFromJsDoc(functionSymbol, functionIsReadonly) {
    const parallelDegreeTag = functionSymbol.getJsDocTags().find(e => e.name === "paralleldegree");
    if (parallelDegreeTag === undefined) {
        return new result_1.Ok(null);
    }
    else {
        if (!functionIsReadonly)
            return new result_1.Err(["The @paralleldegree JSDoc tag is only supported on functions also marked with the @readonly JSDoc tag"]);
        const tagSymbolDisplayPart = parallelDegreeTag.text?.[0];
        if (tagSymbolDisplayPart === undefined)
            return new result_1.Err(["The @paralleldegree JSDoc tag must specify an integer degree value"]);
        const tagText = tagSymbolDisplayPart.text.trim();
        const parallelDegreeInt = parseInt(tagText, 10);
        if (isNaN(parallelDegreeInt) || parallelDegreeInt <= 0)
            return new result_1.Err([`The @paralleldegree JSDoc tag must specify an integer degree value that is greater than 0. Current value: '${tagText}'`]);
        return new result_1.Ok(parallelDegreeInt);
    }
}
function deriveSchemaTypeForTsType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    const typeRenderedName = context.typeChecker.typeToString(tsType);
    if (unwrapPromiseType(tsType, context.typeChecker) !== undefined) {
        return new result_1.Err([`Promise types are not supported, but one was encountered in ${schema.typePathToString(typePath)}.`]);
    }
    if (tsutils.isIntrinsicVoidType(tsType)) {
        return new result_1.Err([`The void type is not supported, but one was encountered in ${schema.typePathToString(typePath)}`]);
    }
    if (tsutils.isIntrinsicNeverType(tsType)) {
        return new result_1.Err([`The never type is not supported, but one was encountered in ${schema.typePathToString(typePath)}`]);
    }
    if (tsutils.isIntrinsicNonPrimitiveType(tsType)) {
        return new result_1.Err([`The object type is not supported, but one was encountered in ${schema.typePathToString(typePath)}`]);
    }
    if (tsutils.isIntrinsicNullType(tsType)) {
        return new result_1.Err([`The null type is not supported as a type literal used on its own, but one was encountered in ${schema.typePathToString(typePath)}`]);
    }
    if (tsutils.isIntrinsicUndefinedType(tsType)) {
        return new result_1.Err([`The undefined type is not supported as a type literal used on its own, but one was encountered in ${schema.typePathToString(typePath)}`]);
    }
    if (isFunctionType(tsType)) {
        return new result_1.Err([`Function types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${context.typeChecker.typeToString(tsType)})`]);
    }
    if (isMapType(tsType)) {
        return new result_1.Err([`Map types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${context.typeChecker.typeToString(tsType)})`]);
    }
    const schemaTypeResult = deriveSchemaTypeIfTsUnknownOrAny(tsType, typeSource, typePath, allowRelaxedTypes, context)
        ?? deriveSchemaTypeIfTsTupleType(tsType, typeSource, typePath, allowRelaxedTypes, context)
        ?? deriveSchemaTypeIfTsArrayType(tsType, typeSource, typePath, allowRelaxedTypes, context)
        ?? deriveSchemaTypeIfBuiltInScalarType(tsType, context)
        ?? deriveSchemaTypeIfNullableType(tsType, typeSource, typePath, allowRelaxedTypes, context)
        ?? deriveSchemaTypeIfEnumType(tsType, typeSource, typePath, allowRelaxedTypes, context)
        ?? deriveSchemaTypeIfObjectType(tsType, typeSource, typePath, allowRelaxedTypes, context)
        ?? rejectIfClassType(tsType, typePath, context) // This needs to be done after scalars, because JSONValue is a class
        ?? deriveSchemaTypeIfTsIndexSignatureType(tsType, typeSource, typePath, allowRelaxedTypes, context) // This needs to be done after scalars and classes, etc because some of those types do have index signatures (eg. strings)
        ?? deriveSchemaTypeIfTsUnionType(tsType, typeSource, typePath, allowRelaxedTypes, context); // This needs to be done after nullable types, since nullable types use unions, this catches everything else
    if (schemaTypeResult !== undefined)
        return schemaTypeResult;
    // We don't know how to deal with this type, so reject it with a generic error
    return new result_1.Err([`Unable to derive an NDC type for ${schema.typePathToString(typePath)} (type: ${context.typeChecker.typeToString(tsType)}).`]);
}
function deriveRelaxedTypeOrError(preferredTypeName, tsType, typeSource, typePath, mkError, allowRelaxedTypes, context) {
    if (allowRelaxedTypes === false) {
        return new result_1.Err([mkError()]);
    }
    const uniqueTypeIdentifier = makeUniqueTypeIdentifier(tsType, typeSource, context.typeChecker);
    context.customTypeNameRegistry.registerUniqueType(uniqueTypeIdentifier, tsType, typeSource, preferredTypeName);
    let scalarTypeDefinition = context.scalarTypeDefinitions[uniqueTypeIdentifier];
    if (scalarTypeDefinition === undefined) {
        scalarTypeDefinition = { type: "relaxed-type", usedIn: [typePath] };
        context.scalarTypeDefinitions[uniqueTypeIdentifier] = scalarTypeDefinition;
    }
    else if (scalarTypeDefinition.type === "relaxed-type") {
        scalarTypeDefinition.usedIn.push(typePath);
    }
    else {
        throw new Error(`Scalar type name conflict. Trying to create relaxed type '${uniqueTypeIdentifier}' but it already exists as a ${scalarTypeDefinition.type}`);
    }
    return new result_1.Ok({ type: "named", kind: "scalar", name: uniqueTypeIdentifier });
}
function deriveSchemaTypeIfTsUnknownOrAny(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    if (tsutils.isIntrinsicUnknownType(tsType)) {
        return deriveRelaxedTypeOrError("unknown", tsType, typeSource, typePath, () => `The unknown type is not supported, but one was encountered in ${schema.typePathToString(typePath)}`, allowRelaxedTypes, context);
    }
    if (tsutils.isIntrinsicAnyType(tsType)) {
        return deriveRelaxedTypeOrError("any", tsType, typeSource, typePath, () => `The any type is not supported, but one was encountered in ${schema.typePathToString(typePath)}`, allowRelaxedTypes, context);
    }
}
function deriveSchemaTypeIfTsTupleType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    if (tsutils.isTupleTypeReference(tsType)) {
        const typeName = context.typeChecker.typeToString(tsType);
        if (allowRelaxedTypes) {
            // Verify types in tuple are valid types
            const isolatedContext = cloneTypeDerivationContext(context); // Use an isolated context so we don't actually record any new scalar or object types while doing this, since this is going to end up as a relaxed type anyway
            const result = result_1.Result.traverseAndCollectErrors(tsType.typeArguments ?? [], (typeParameterTsType, index) => {
                return deriveSchemaTypeForTsType(typeParameterTsType, typeSource, [...typePath, { segmentType: "TypeParameter", typeName, index }], allowRelaxedTypes, isolatedContext);
            });
            if (result instanceof result_1.Err)
                return new result_1.Err(result.error);
        }
        return deriveRelaxedTypeOrError(typeName, tsType, typeSource, typePath, () => `Tuple types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${typeName})`, allowRelaxedTypes, context);
    }
}
function rejectIfClassType(tsType, typePath, context) {
    if (tsutils.isObjectType(tsType) && tsutils.isObjectFlagSet(tsType, typescript_1.default.ObjectFlags.Class)) {
        return new result_1.Err([`Class types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${context.typeChecker.typeToString(tsType)})`]);
    }
}
// Types with index signatures: ie '[x: T]: Y'
function deriveSchemaTypeIfTsIndexSignatureType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    const indexInfos = context.typeChecker.getIndexInfosOfType(tsType);
    if (indexInfos.length > 0) {
        const typeName = context.typeChecker.typeToString(tsType);
        if (allowRelaxedTypes) {
            // Verify the types used in the index signatures are valid
            const isolatedContext = cloneTypeDerivationContext(context); // Use an isolated context so we don't actually record any new scalar or object types while doing this, since this is going to end up as a relaxed type anyway
            const indexSignatureTypes = indexInfos.flatMap((indexInfo, sigIndex) => [
                [indexInfo.keyType, { segmentType: "IndexSignature", typeName, sigIndex, component: "key" }],
                [indexInfo.type, { segmentType: "IndexSignature", typeName, sigIndex, component: "value" }],
            ]);
            const result = result_1.Result.traverseAndCollectErrors(indexSignatureTypes, ([sigType, typePathSegment]) => {
                return deriveSchemaTypeForTsType(sigType, typeSource, [...typePath, typePathSegment], allowRelaxedTypes, isolatedContext);
            });
            if (result instanceof result_1.Err)
                return new result_1.Err(result.error);
        }
        return deriveRelaxedTypeOrError(typeName, tsType, typeSource, typePath, () => `Types with index signatures are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${typeName})`, allowRelaxedTypes, context);
    }
}
function deriveSchemaTypeIfTsUnionType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    if (tsType.isUnion()) {
        const typeName = context.typeChecker.typeToString(tsType);
        if (allowRelaxedTypes) {
            // Verify union options are valid types
            const isolatedContext = cloneTypeDerivationContext(context); // Use an isolated context so we don't actually record any new scalar or object types while doing this, since this is going to end up as a relaxed type anyway
            const result = result_1.Result.traverseAndCollectErrors(tsType.types, (memberTsType, memberIndex) => {
                return deriveSchemaTypeForTsType(memberTsType, typeSource, [...typePath, { segmentType: "UnionMember", typeName, memberIndex }], allowRelaxedTypes, isolatedContext);
            });
            if (result instanceof result_1.Err)
                return new result_1.Err(result.error);
        }
        return deriveRelaxedTypeOrError(typeName, tsType, typeSource, typePath, () => `Union types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${typeName})`, allowRelaxedTypes, context);
    }
}
function deriveSchemaTypeIfTsArrayType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    if (context.typeChecker.isArrayType(tsType) && tsutils.isTypeReference(tsType)) {
        const typeArgs = context.typeChecker.getTypeArguments(tsType);
        if (typeArgs.length === 1) {
            const innerType = typeArgs[0];
            return deriveSchemaTypeForTsType(innerType, typeSource, [...typePath, { segmentType: "Array" }], allowRelaxedTypes, context)
                .map(innerType => ({ type: "array", elementType: innerType }));
        }
    }
}
function deriveSchemaTypeIfBuiltInScalarType(tsType, context) {
    if (tsutils.isIntrinsicBooleanType(tsType) || isBooleanUnionType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.Boolean] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.Boolean });
    }
    if (tsutils.isBooleanLiteralType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.Boolean] = { type: "built-in" };
        const literalValue = tsType.intrinsicName === "true" ? true : false; // Unfortunately the types lie, tsType.value is undefined here :(
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.Boolean, literalValue: literalValue });
    }
    if (tsutils.isIntrinsicStringType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.String] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.String });
    }
    if (tsutils.isStringLiteralType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.String] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.String, literalValue: tsType.value });
    }
    if (tsutils.isIntrinsicNumberType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.Float] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.Float });
    }
    if (tsutils.isNumberLiteralType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.Float] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.Float, literalValue: tsType.value });
    }
    if (tsutils.isIntrinsicBigIntType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.BigInt] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.BigInt });
    }
    if (tsutils.isBigIntLiteralType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.BigInt] = { type: "built-in" };
        const literalValue = BigInt(`${tsType.value.negative ? "-" : ""}${tsType.value.base10Value}`);
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.BigInt, literalValue: literalValue });
    }
    if (isDateType(tsType)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.DateTime] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.DateTime });
    }
    if (isJSONValueType(tsType, context.ndcLambdaSdkModule)) {
        context.scalarTypeDefinitions[schema.BuiltInScalarTypeName.JSON] = { type: "built-in" };
        return new result_1.Ok({ type: "named", kind: "scalar", name: schema.BuiltInScalarTypeName.JSON });
    }
}
function deriveSchemaTypeIfEnumType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    if (tsutils.isUnionType(tsType) && !tsutils.isIntrinsicType(tsType) /* Block booleans */) {
        const typeName = context.typeChecker.typeToString(tsType);
        // Handles 'enum { First, Second }'
        if (tsutils.isTypeFlagSet(tsType, typescript_1.default.TypeFlags.EnumLiteral)) {
            return deriveRelaxedTypeOrError(typeName, tsType, typeSource, typePath, () => `Enum types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${typeName})`, allowRelaxedTypes, context);
        }
        // Handles `"first" | "second"`
        if (tsType.types.every(unionMemberType => tsutils.isLiteralType(unionMemberType))) {
            return deriveRelaxedTypeOrError(typeName, tsType, typeSource, typePath, () => `Literal union types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${typeName})`, allowRelaxedTypes, context);
        }
    }
    // Handles computed single member enum types: 'enum { OneThing = "test".length }'
    else if (tsutils.isEnumType(tsType) && tsutils.isSymbolFlagSet(tsType.symbol, typescript_1.default.SymbolFlags.EnumMember)) {
        const typeName = context.typeChecker.typeToString(tsType);
        return deriveRelaxedTypeOrError(typeName, tsType, typeSource, typePath, () => `Enum types are not supported, but one was encountered in ${schema.typePathToString(typePath)} (type: ${typeName})`, allowRelaxedTypes, context);
    }
    // Note that single member enum types: 'enum { OneThing }' are simplified by the type system
    // down to literal types (since they can only be a single thing) and are therefore supported via support
    // for literal types in scalars
}
function isDateType(tsType) {
    const symbol = tsType.getSymbol();
    if (symbol === undefined)
        return false;
    return symbol.escapedName === "Date" && symbol.members?.has(typescript_1.default.escapeLeadingUnderscores("toISOString")) === true;
}
function isFunctionType(tsType) {
    return tsType.getCallSignatures().length > 0 || tsType.getConstructSignatures().length > 0;
}
function isMapType(tsType) {
    const symbol = tsType.getSymbol();
    if (symbol === undefined)
        return false;
    return symbol.escapedName === "Map" && symbol.members?.has(typescript_1.default.escapeLeadingUnderscores("keys")) === true && symbol.members?.has(typescript_1.default.escapeLeadingUnderscores("values")) === true && symbol.members?.has(typescript_1.default.escapeLeadingUnderscores("entries")) === true;
}
// Identifies the 'true | false' type (which is distinct from the 'boolean' type)
function isBooleanUnionType(tsType) {
    if (!tsutils.isUnionType(tsType))
        return false;
    return tsType.types.length === 2
        && tsType.types.find(type => tsutils.isBooleanLiteralType(type) && type.intrinsicName === "true") !== undefined
        && tsType.types.find(type => tsutils.isBooleanLiteralType(type) && type.intrinsicName === "false") !== undefined;
}
function isJSONValueType(tsType, ndcLambdaSdkModule) {
    // Must be a class type
    if (!tsutils.isObjectType(tsType) || !tsutils.isObjectFlagSet(tsType, typescript_1.default.ObjectFlags.Class))
        return false;
    // Must be called JSONValue
    const symbol = tsType.getSymbol();
    if (symbol === undefined || symbol.escapedName !== "JSONValue")
        return false;
    // Must be declared in a file in the ndc-lambda-sdk's module directory (ie. this is _our_ JSONValue class)
    const sourceFile = symbol.getDeclarations()?.[0]?.getSourceFile();
    if (sourceFile === undefined)
        return false;
    const sdkDirectory = node_path_1.default.dirname(ndcLambdaSdkModule.resolvedFileName);
    return sourceFile.fileName.startsWith(sdkDirectory);
}
function deriveSchemaTypeIfNullableType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    const notNullableResult = unwrapNullableType(tsType, context.typeChecker);
    if (notNullableResult !== null) {
        const [notNullableType, nullOrUndefinability] = notNullableResult;
        return deriveSchemaTypeForTsType(notNullableType, typeSource, typePath, allowRelaxedTypes, context)
            .map(notNullableType => ({ type: "nullable", underlyingType: notNullableType, nullOrUndefinability }));
    }
}
function deriveSchemaTypeIfObjectType(tsType, typeSource, typePath, allowRelaxedTypes, context) {
    const info = getObjectTypeInfo(tsType, typeSource, typePath, context.typeChecker);
    if (info) {
        const makeRelaxedTypesError = () => new result_1.Err([`The object type '${info.preferredTypeName}' uses relaxed types and can only be used by a function marked with @allowrelaxedtypes. It was encountered in ${schema.typePathToString(typePath)}`]);
        // Short-circuit recursion if the type has already been named
        const existingType = context.objectTypeDefinitions[info.uniqueTypeIdentifier];
        if (existingType) {
            if (allowRelaxedTypes === false && existingType.isRelaxedType)
                return makeRelaxedTypesError();
            return new result_1.Ok({ type: 'named', name: info.uniqueTypeIdentifier, kind: "object" });
        }
        context.objectTypeDefinitions[info.uniqueTypeIdentifier] = { properties: [], description: null, isRelaxedType: false }; // Break infinite recursion
        return result_1.Result.traverseAndCollectErrors(Array.from(info.properties), ([propertyName, propertyInfo]) => {
            return deriveSchemaTypeForTsType(propertyInfo.tsType, { type: "Symbol", symbol: propertyInfo.symbol }, [...typePath, { segmentType: "ObjectProperty", typeName: context.typeChecker.typeToString(tsType), preferredTypeName: info.preferredTypeName, propertyName }], allowRelaxedTypes, context)
                .map(propertyType => ({ propertyName: propertyName, type: propertyType, description: propertyInfo.description }));
        })
            .bind(propertyResults => {
            const isRelaxedType = propertyResults.some(propDef => isTypeReferenceARelaxedType(propDef.type, context));
            if (allowRelaxedTypes === false && isRelaxedType) {
                return makeRelaxedTypesError();
            }
            context.customTypeNameRegistry.registerUniqueType(info.uniqueTypeIdentifier, tsType, typeSource, info.preferredTypeName);
            context.objectTypeDefinitions[info.uniqueTypeIdentifier] = { properties: propertyResults, description: info.description, isRelaxedType };
            return new result_1.Ok({ type: 'named', name: info.uniqueTypeIdentifier, kind: "object" });
        })
            .onErr(_err => {
            delete context.objectTypeDefinitions[info.uniqueTypeIdentifier]; // Remove the recursion short-circuit to allow other functions to try making this type again
        });
    }
}
function isTypeReferenceARelaxedType(typeReference, context) {
    switch (typeReference.type) {
        case "array":
            return isTypeReferenceARelaxedType(typeReference.elementType, context);
        case "nullable":
            return isTypeReferenceARelaxedType(typeReference.underlyingType, context);
        case "named":
            switch (typeReference.kind) {
                case "object":
                    const objTypeDef = context.objectTypeDefinitions[typeReference.name] ?? (0, util_1.throwError)(`Unable to find object type '${typeReference.name}', which should have already been generated`);
                    return objTypeDef.isRelaxedType;
                case "scalar":
                    const scalarTypeDef = context.scalarTypeDefinitions[typeReference.name] ?? (0, util_1.throwError)(`Unable to find object type '${typeReference.name}', which should have already been generated`);
                    return scalarTypeDef.type === "relaxed-type";
                default:
                    return (0, util_1.unreachable)(typeReference["kind"]);
            }
        default:
            return (0, util_1.unreachable)(typeReference["type"]);
    }
}
function unwrapPromiseType(tsType, typeChecker) {
    if (tsutils.isTypeReference(tsType) && tsType.getSymbol()?.getName() === "Promise") {
        const typeArgs = typeChecker.getTypeArguments(tsType);
        return typeArgs.length === 1
            ? typeArgs[0]
            : undefined; // This isn't a real Promise if it doesn't have exactly one type argument
    }
    else {
        return undefined; // Not a Promise
    }
}
function unwrapNullableType(tsType, typeChecker) {
    if (!tsType.isUnion())
        return null;
    const isNullable = tsType.types.find(tsutils.isIntrinsicNullType) !== undefined;
    const isUndefined = tsType.types.find(tsutils.isIntrinsicUndefinedType) !== undefined;
    const nullOrUndefinability = isNullable
        ? (isUndefined
            ? schema.NullOrUndefinability.AcceptsEither
            : schema.NullOrUndefinability.AcceptsNullOnly)
        : (isUndefined
            ? schema.NullOrUndefinability.AcceptsUndefinedOnly
            : null);
    return nullOrUndefinability
        ? [typeChecker.getNonNullableType(tsType), nullOrUndefinability]
        : null;
}
// Anonymous object type - this covers:
// - {a: number, b: string}
// - type Bar = { test: string }
// - type GenericBar<T> = { data: T }
function isAnonymousObjectType(tsType) {
    return tsutils.isObjectType(tsType) && tsutils.isObjectFlagSet(tsType, typescript_1.default.ObjectFlags.Anonymous);
}
// Interface type - this covers:
// interface IThing { test: string }
// type AliasedIThing = IThing (the alias is erased by the compiler)
function isInterfaceType(tsType) {
    return tsutils.isObjectType(tsType) && tsutils.isObjectFlagSet(tsType, typescript_1.default.ObjectFlags.Interface);
}
// Generic interface type - this covers:
// interface IGenericThing<T> { data: T }
// type AliasedIGenericThing<T> = IGenericThing<T>
// type AliasedClosedIGenericThing = IGenericThing<string>
function isGenericInterfaceType(tsType, typeChecker) {
    return tsutils.isTypeReference(tsType) && tsutils.isObjectFlagSet(tsType.target, typescript_1.default.ObjectFlags.Interface)
        && typeChecker.isArrayType(tsType) === false && tsType.getSymbol()?.getName() !== "Promise";
}
function getObjectTypeInfo(tsType, typeSource, typePath, typeChecker) {
    // If the type has an index signature (ie '[x: T]: Y'), we don't support that (yet) so exclude it
    if (typeChecker.getIndexInfosOfType(tsType).length > 0) {
        return null;
    }
    // If it's none of the types we recognise as object types, exclude it
    if (!isAnonymousObjectType(tsType) && !isInterfaceType(tsType)
        && !isGenericInterfaceType(tsType, typeChecker) && !tsutils.isIntersectionType(tsType)) {
        return null;
    }
    const symbolForDocs = tsType.aliasSymbol ?? tsType.getSymbol();
    return {
        uniqueTypeIdentifier: makeUniqueTypeIdentifier(tsType, typeSource, typeChecker),
        preferredTypeName: 
        // If the type is an anonymous type, and doesn't have an alias, generate a type name
        // otherwise just use the given type name
        (isAnonymousObjectType(tsType) || tsutils.isIntersectionType(tsType)) && !tsType.aliasSymbol
            ? generateTypeNameFromTypePath(typePath)
            : typeChecker.typeToString(tsType),
        properties: getMembers(tsType.getProperties(), typeChecker),
        description: symbolForDocs ? getDescriptionFromJsDoc(symbolForDocs, typeChecker) : null,
    };
}
function getMembers(propertySymbols, typeChecker) {
    return new Map(propertySymbols.map(symbol => {
        const tsType = typeChecker.getTypeOfSymbol(symbol);
        const description = getDescriptionFromJsDoc(symbol, typeChecker);
        return [symbol.name, { tsType, symbol, description }];
    }));
}
function generateTypeNameFromTypePath(typePath) {
    if (typePath.length === 0)
        throw new Error("Unexpected empty type path when generating type name");
    const lastSegment = typePath[typePath.length - 1];
    switch (lastSegment.segmentType) {
        // Realistically, while we don't support union types, these are the segment types we're
        // likely to encounter in non-relaxed types.
        case "FunctionParameter": return `${lastSegment.functionName}_${lastSegment.parameterName}`;
        case "FunctionReturn": return `${lastSegment.functionName}_output`;
        case "ObjectProperty": return `${lastSegment.preferredTypeName}_${lastSegment.propertyName}`;
        case "Array": return `array`;
        case "TypeParameter": return `typeparam_${lastSegment.index}`;
        case "IndexSignature": return `indexsig_${lastSegment.sigIndex}_${lastSegment.segmentType}`;
        case "UnionMember": return `union_${lastSegment.memberIndex}`;
        default: return (0, util_1.unreachable)(lastSegment["segmentType"]);
    }
}
class CustomTypeNameRegistry {
    _uniqueTypes = {};
    _preferredTypeNameContenders = {};
    registerUniqueType(uniqueTypeIdentifier, tsType, typeSource, preferredTypeName) {
        if (this._uniqueTypes[uniqueTypeIdentifier] !== undefined)
            return; // Already registered
        this._uniqueTypes[uniqueTypeIdentifier] = { preferredName: preferredTypeName, typeSource, tsType };
        const contenders = this._preferredTypeNameContenders[preferredTypeName] ?? [];
        contenders.push(uniqueTypeIdentifier);
        this._preferredTypeNameContenders[preferredTypeName] = contenders;
    }
    determineFinalTypeNames(projectRootDir, typeChecker) {
        const usedNames = new Set(Object.values(schema.BuiltInScalarTypeName)); // Built-in names are reserved already
        // This ensures that whatever name we've chosen is actually unique.
        // If it is not, we slap a number on the end until we find an unused name.
        // We try to avoid doing this by providing unique-ish names to begin with
        // but it may be possible to defeat that system, so we have this backup.
        const allocateName = (name) => {
            let proposedName = name;
            for (let index = 2; usedNames.has(proposedName); index++) {
                if (index >= Number.MAX_SAFE_INTEGER)
                    throw new Error(`Unable to find an unused name for '${name}'. Reached MAX_SAFE_INTEGER`);
                proposedName = `${proposedName}${index}`;
            }
            usedNames.add(proposedName);
            return proposedName;
        };
        return (0, util_1.mapObjectValues)(this._uniqueTypes, (typeInfo, uniqueTypeName) => {
            const preferredNameContenders = this._preferredTypeNameContenders[typeInfo.preferredName] ?? [];
            const name = preferredNameContenders.length === 1
                ? typeInfo.preferredName
                : deriveFullyQualifiedName(typeInfo, projectRootDir, typeChecker);
            return allocateName(name);
        });
    }
    clone() {
        const cloned = new CustomTypeNameRegistry();
        cloned._uniqueTypes = (0, util_1.mapObjectValues)(this._uniqueTypes, typeInfo => ({ ...typeInfo }));
        cloned._preferredTypeNameContenders = (0, util_1.mapObjectValues)(this._preferredTypeNameContenders, contenders => [...contenders]);
        return cloned;
    }
}
/**
 * Create a unique identifier for a type by forming a string describing the location of where the type is declared in code.
 * This is actually a massive pain because TypeScript is structurally typed, but NDC is nominally typed; ie NDC gives
 * every type a unique name, and TypeScript doesn't because it really only cares about type structure.
 * By creating a unique identifier for each type, we can track every place it is used and then give it a human-readable
 * NDC type name at the end, ensuring no two unique types have the same name (see 'CustomTypeNameRegistry').
 */
function makeUniqueTypeIdentifier(tsType, typeSource, typeChecker) {
    const compareList = (compare, listA, listB) => {
        const lengthCompare = listA.length - listB.length;
        if (lengthCompare !== 0)
            return lengthCompare;
        for (let i = 0; i < listA.length; i++) {
            const itemCompare = compare(listA[i], listB[i]);
            if (itemCompare !== 0)
                return itemCompare;
        }
        return 0;
    };
    const compareTypeId = (typeIdA, typeIdB) => {
        if (typeIdA.t === "d" && typeIdB.t == "d") {
            return typeIdA.f.localeCompare(typeIdB.f)
                || typeIdA.s - typeIdB.s
                || compareList(compareTypeId, typeIdA.ta, typeIdB.ta);
        }
        else if (typeIdA.t === "i" && typeIdB.t == "i") {
            return typeIdA.i.localeCompare(typeIdB.i);
        }
        else if (typeIdA.t === "l-n" && typeIdB.t == "l-n") {
            return typeIdA.v - typeIdB.v;
        }
        else if (typeIdA.t === "l-s" && typeIdB.t == "l-s") {
            return typeIdA.v.localeCompare(typeIdB.v);
        }
        else if (typeIdA.t === "l-bi" && typeIdB.t == "l-bi") {
            const aStr = `${typeIdA.v.negative ? "-" : ""}${typeIdA.v.base10Value}`;
            const bStr = `${typeIdB.v.negative ? "-" : ""}${typeIdB.v.base10Value}`;
            return aStr.localeCompare(bStr);
        }
        else if (typeIdA.t === "o" && typeIdB.t == "o") {
            return compareList(([nameA, pTypeIdA], [nameB, pTypeIdB]) => nameA.localeCompare(nameB) || compareTypeId(pTypeIdA, pTypeIdB), typeIdA.p, typeIdB.p);
        }
        else if (typeIdA.t === "u" && typeIdB.t == "u") {
            return compareList(compareTypeId, typeIdA.u, typeIdB.u);
        }
        else if (typeIdA.t === "in" && typeIdB.t == "in") {
            return compareList(compareTypeId, typeIdA.in, typeIdB.in);
        }
        else {
            return typeIdA.t.localeCompare(typeIdB.t);
        }
    };
    const deriveTypeId = (tsType) => {
        // Intrinsics, such as string, number, any, etc
        if (tsutils.isIntrinsicType(tsType)) {
            return { t: "i", i: tsType.intrinsicName };
        }
        // Type literals (can be strings, numbers and bigints)
        if (tsType.isLiteral()) {
            if (typeof tsType.value === "string") {
                return { t: "l-s", v: tsType.value };
            }
            else if (typeof tsType.value === "number") {
                return { t: "l-n", v: tsType.value };
            }
            else {
                return { t: "l-bi", v: tsType.value };
            }
        }
        // Anonymous object type (identity is the object properties and their types)
        if (!tsType.aliasSymbol && isAnonymousObjectType(tsType)) {
            return {
                t: "o",
                p: tsType.getProperties()
                    .map(propSymbol => [propSymbol.name, deriveTypeId(typeChecker.getTypeOfSymbol(propSymbol))])
                    .sort(([nameA], [nameB]) => nameA.localeCompare(nameB))
            };
        }
        // Anonymous union types (identity is the sorted array of identities of the types that make up the union)
        if (!tsType.aliasSymbol && tsType.isUnion()) {
            return { t: "u", u: tsType.types.map(deriveTypeId).sort(compareTypeId) }; // We sort the types to ensure 'TypeA | TypeB' is the same as 'TypeA | TypeB'
        }
        // Anonymous intersection types (identity is the sorted array of identities of the types that make up the intersection)
        if (!tsType.aliasSymbol && tsType.isIntersection()) {
            return { t: "in", in: tsType.types.map(deriveTypeId).sort(compareTypeId) }; // We sort the types to ensure 'TypeA & TypeB' is the same as 'TypeB & TypeA'
        }
        const declaration = getDeclarationFromTypeOrTypeSource(tsType, typeSource, typeChecker);
        const typeArguments = tsType.aliasTypeArguments ?? (tsutils.isTypeReference(tsType) ? tsType.typeArguments : undefined) ?? [];
        const typeArgumentTypeIds = typeArguments.map(deriveTypeId);
        return {
            t: "d",
            f: declaration.getSourceFile().fileName,
            s: declaration.getStart(),
            ta: typeArgumentTypeIds,
        };
    };
    return JSON.stringify(deriveTypeId(tsType));
}
function getDeclarationFromTypeOrTypeSource(tsType, typeSource, typeChecker) {
    const symbolFromType = tsType.aliasSymbol ?? tsType.getSymbol();
    if (symbolFromType) {
        return symbolFromType.getDeclarations()?.[0] ?? (0, util_1.throwError)(`Couldn't find declaration of symbol for type '${typeChecker.typeToString(tsType)}'`);
    }
    else {
        // Otherwise try to get the declaration of the source of the type's symbol
        // (eg. a function return value, a object property symbol or a function parameter symbol)
        switch (typeSource.type) {
            case "FunctionReturn":
                return typeSource.callSignature.getDeclaration();
            case "Symbol":
                return typeSource.symbol.getDeclarations()?.[0] ?? (0, util_1.throwError)(`Couldn't find declaration of type source symbol for type '${typeChecker.typeToString(tsType)}'`);
            default:
                return (0, util_1.unreachable)(typeSource["type"]);
        }
    }
}
function deriveFullyQualifiedName(uniqueTypeInfo, projectRootDir, typeChecker) {
    const declaration = getDeclarationFromTypeOrTypeSource(uniqueTypeInfo.tsType, uniqueTypeInfo.typeSource, typeChecker);
    const fileName = declaration.getSourceFile().fileName;
    const shortenedFileName = stripNodeModulesDirectory(fileName)
        ?? stripProjectRootPath(fileName, projectRootDir)
        ?? fileName;
    const moduleNameComponent = dropFileExtension(shortenedFileName).replaceAll(/[\\\/]/g, "_");
    return `${moduleNameComponent}_${uniqueTypeInfo.preferredName}`;
}
/**
 * Keeps the part of the path after the last node_modules directory
 *
 * `/functions/node_modules/@opentelemetry/api/build/src/metrics/Meter` ->
 * `@opentelemetry/api/build/src/metrics/Meter`
 */
function stripNodeModulesDirectory(filepath) {
    const nodeModulesRegex = /node_modules[\\\/]/g;
    let lastIndex = null;
    let execResult = nodeModulesRegex.exec(filepath);
    while (execResult) {
        lastIndex = execResult.index + execResult[0].length;
        execResult = nodeModulesRegex.exec(filepath);
    }
    return lastIndex !== null
        ? filepath.substring(lastIndex)
        : null;
}
function stripProjectRootPath(filepath, projectRootDir) {
    // Add a / to the end if it does not exist
    projectRootDir = projectRootDir.endsWith(node_path_1.default.sep) ? projectRootDir : projectRootDir + node_path_1.default.sep;
    return filepath.startsWith(projectRootDir)
        ? filepath.substring(projectRootDir.length)
        : null;
}
function dropFileExtension(filePath) {
    const extension = node_path_1.default.extname(filePath);
    return extension !== ""
        ? filePath.substring(0, filePath.length - extension.length)
        : filePath;
}
function applyFinalTypeNamesToFunctionsSchema(functionsSchema, finalTypeNames) {
    return {
        functions: (0, util_1.mapObjectValues)(functionsSchema.functions, definition => ({
            ...definition,
            arguments: definition.arguments.map(arg => ({ ...arg, type: applyFinalTypeName(arg.type, finalTypeNames) })),
            resultType: applyFinalTypeName(definition.resultType, finalTypeNames),
        })),
        objectTypes: Object.fromEntries(Object.entries(functionsSchema.objectTypes).map(([objectTypeName, definition]) => {
            const newObjectTypeName = finalTypeNames[objectTypeName] ?? (0, util_1.throwError)(`Unable to find unique type name '${objectTypeName}'`);
            const newDefinition = {
                ...definition,
                properties: definition.properties.map(prop => ({ ...prop, type: applyFinalTypeName(prop.type, finalTypeNames) })),
            };
            return [newObjectTypeName, newDefinition];
        })),
        scalarTypes: Object.fromEntries(Object.entries(functionsSchema.scalarTypes).map(([scalarTypeName, definition]) => {
            const newScalarTypeName = schema.isTypeNameBuiltInScalar(scalarTypeName)
                ? scalarTypeName // Built-in types already have their final name
                : finalTypeNames[scalarTypeName] ?? (0, util_1.throwError)(`Unable to find unique type name '${scalarTypeName}'`);
            return [newScalarTypeName, definition];
        })),
    };
}
function applyFinalTypeName(typeReference, finalTypeNames) {
    switch (typeReference.type) {
        case "array":
            return { ...typeReference, elementType: applyFinalTypeName(typeReference.elementType, finalTypeNames) };
        case "nullable":
            return { ...typeReference, underlyingType: applyFinalTypeName(typeReference.underlyingType, finalTypeNames) };
        case "named":
            return schema.isTypeNameBuiltInScalar(typeReference.name)
                ? typeReference // Built-in types already have their final name
                : { ...typeReference, name: finalTypeNames[typeReference.name] ?? (0, util_1.throwError)(`Unable to find unique type name '${typeReference.name}'`) };
        default:
            return (0, util_1.unreachable)(typeReference["type"]);
    }
}
//# sourceMappingURL=inference.js.map