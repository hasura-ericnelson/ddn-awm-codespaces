declare abstract class ResultBase<T, TError> {
    map<T2>(fn: (r: T) => T2): Result<T2, TError>;
    mapErr<TError2>(fn: (r: TError) => TError2): Result<T, TError2>;
    bind<T2>(fn: (r: T) => Result<T2, TError>): Result<T2, TError>;
    onErr(fn: (r: TError) => void): Result<T, TError>;
}
export declare class Ok<T, TError> extends ResultBase<T, TError> {
    readonly data: T;
    constructor(data: T);
}
export declare class Err<T, TError> extends ResultBase<T, TError> {
    readonly error: TError;
    constructor(error: TError);
}
export type Result<T, TError> = Ok<T, TError> | Err<T, TError>;
declare function traverseAndCollectErrors<T1, T2, TErr>(inputs: readonly T1[], fn: (input: T1, index: number) => Result<T2, TErr[]>): Result<T2[], TErr[]>;
declare function sequenceAndCollectErrors<T, TErr>(results: readonly Result<T, TErr[]>[]): Result<T[], TErr[]>;
declare function partitionAndCollectErrors<T, TErr>(results: readonly Result<T, TErr[]>[]): {
    oks: T[];
    errs: TErr[];
};
declare function collectErrors<T1, T2, TErr>(result1: Result<T1, TErr[]>, result2: Result<T2, TErr[]>): Result<[T1, T2], TErr[]>;
declare function collectErrors3<T1, T2, T3, TErr>(result1: Result<T1, TErr[]>, result2: Result<T2, TErr[]>, result3: Result<T3, TErr[]>): Result<[T1, T2, T3], TErr[]>;
export declare const Result: {
    traverseAndCollectErrors: typeof traverseAndCollectErrors;
    sequenceAndCollectErrors: typeof sequenceAndCollectErrors;
    partitionAndCollectErrors: typeof partitionAndCollectErrors;
    collectErrors: typeof collectErrors;
    collectErrors3: typeof collectErrors3;
};
export {};
//# sourceMappingURL=result.d.ts.map