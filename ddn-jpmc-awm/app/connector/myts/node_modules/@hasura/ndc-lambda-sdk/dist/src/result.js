"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Result = exports.Err = exports.Ok = void 0;
class ResultBase {
    map(fn) {
        if (this instanceof Ok) {
            return new Ok(fn(this.data));
        }
        else if (this instanceof Err) {
            return new Err(this.error);
        }
        else {
            throw new Error("Unknown result subclass");
        }
    }
    mapErr(fn) {
        if (this instanceof Ok) {
            return new Ok(this.data);
        }
        else if (this instanceof Err) {
            return new Err(fn(this.error));
        }
        else {
            throw new Error("Unknown result subclass");
        }
    }
    bind(fn) {
        if (this instanceof Ok) {
            return fn(this.data);
        }
        else if (this instanceof Err) {
            return new Err(this.error);
        }
        else {
            throw new Error("Unknown result subclass");
        }
    }
    onErr(fn) {
        if (this instanceof Ok) {
            return this;
        }
        else if (this instanceof Err) {
            fn(this.error);
            return this;
        }
        else {
            throw new Error("Unknown result subclass");
        }
    }
}
class Ok extends ResultBase {
    data;
    constructor(data) {
        super();
        this.data = data;
    }
}
exports.Ok = Ok;
class Err extends ResultBase {
    error;
    constructor(error) {
        super();
        this.error = error;
    }
}
exports.Err = Err;
function traverseAndCollectErrors(inputs, fn) {
    return sequenceAndCollectErrors(inputs.map(fn));
}
function sequenceAndCollectErrors(results) {
    const data = [];
    const errors = [];
    results.forEach(result => {
        if (result instanceof Ok) {
            data.push(result.data);
        }
        else {
            errors.push(...result.error);
        }
    });
    return errors.length > 0
        ? new Err(errors)
        : new Ok(data);
}
function partitionAndCollectErrors(results) {
    const partitionedResults = {
        oks: [],
        errs: [],
    };
    for (const result of results) {
        if (result instanceof Ok) {
            partitionedResults.oks.push(result.data);
        }
        else {
            partitionedResults.errs.push(...result.error);
        }
    }
    return partitionedResults;
}
function collectErrors(result1, result2) {
    if (result1 instanceof Ok && result2 instanceof Ok) {
        return new Ok([result1.data, result2.data]);
    }
    else {
        const errors = [];
        if (result1 instanceof Err)
            errors.push(...result1.error);
        if (result2 instanceof Err)
            errors.push(...result2.error);
        return new Err(errors);
    }
}
function collectErrors3(result1, result2, result3) {
    if (result1 instanceof Ok && result2 instanceof Ok && result3 instanceof Ok) {
        return new Ok([result1.data, result2.data, result3.data]);
    }
    else {
        const errors = [];
        if (result1 instanceof Err)
            errors.push(...result1.error);
        if (result2 instanceof Err)
            errors.push(...result2.error);
        if (result3 instanceof Err)
            errors.push(...result3.error);
        return new Err(errors);
    }
}
exports.Result = {
    traverseAndCollectErrors,
    sequenceAndCollectErrors,
    partitionAndCollectErrors,
    collectErrors,
    collectErrors3,
};
//# sourceMappingURL=result.js.map