"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnector = void 0;
const node_path_1 = __importDefault(require("node:path"));
const schema_1 = require("./schema");
const inference_1 = require("./inference");
const execution_1 = require("./execution");
function createConnector(options) {
    const functionsFilePath = node_path_1.default.resolve(options.functionsFilePath);
    const connector = {
        parseConfiguration: async function (configurationDir) {
            // We need to try imporing the functions code via require before doing schema inference because
            // during watch mode we need it to be registered in the watching system so when the files are
            // changed we reload. If the files fail to compile, ts-node will print the diagnostic errors on the
            // terminal for us
            let runtimeFunctions = undefined;
            try {
                runtimeFunctions = require(functionsFilePath);
            }
            catch (e) {
                console.error(`${e}`); // Print the compiler errors produced by ts-node
                runtimeFunctions = undefined;
            }
            // If the functions successfully loaded (ie. compiled), let's derive the schema.
            // Unfortunately this means we've typechecked everything twice, but that seems unavoidable without
            // implementing our own hot-reloading system instead of using ts-node-dev.
            if (runtimeFunctions !== undefined) {
                const schemaResults = (0, inference_1.deriveSchema)(functionsFilePath);
                (0, inference_1.printCompilerDiagnostics)(schemaResults.compilerDiagnostics); // Should never have any of these, since we've already tried compiling the code above
                (0, inference_1.printFunctionIssues)(schemaResults.functionIssues);
                (0, schema_1.printRelaxedTypesWarning)(schemaResults.functionsSchema);
                return {
                    functionsSchema: schemaResults.functionsSchema,
                    runtimeFunctions,
                };
            }
            // If the functions did not compile, just have an empty schema, the user will need to correct
            // their code before we can derive a schema
            else {
                return {
                    functionsSchema: {
                        functions: {},
                        objectTypes: {},
                        scalarTypes: {},
                    },
                    runtimeFunctions: {}
                };
            }
        },
        tryInitState: async function (configuration, metrics) {
            return {};
        },
        getCapabilities: function (configuration) {
            return {
                version: "0.1.2",
                capabilities: {
                    query: {
                        variables: {}
                    },
                    mutation: {},
                }
            };
        },
        getSchema: async function (configuration) {
            return (0, schema_1.getNdcSchema)(configuration.functionsSchema);
        },
        query: async function (configuration, state, request) {
            return await (0, execution_1.executeQuery)(request, configuration.functionsSchema, configuration.runtimeFunctions);
        },
        mutation: async function (configuration, state, request) {
            return await (0, execution_1.executeMutation)(request, configuration.functionsSchema, configuration.runtimeFunctions);
        },
        queryExplain: function (configuration, state, request) {
            throw new Error("Function not implemented.");
        },
        mutationExplain: function (configuration, state, request) {
            throw new Error("Function not implemented.");
        },
        healthCheck: async function (configuration, state) {
            return undefined;
        },
        fetchMetrics: async function (configuration, state) {
            return undefined;
        },
    };
    return connector;
}
exports.createConnector = createConnector;
//# sourceMappingURL=connector.js.map